---
layout: single
title: "220210_정리노트 2"
categories:
  - eip_w
---

<style>
img.aligncenter{display:block;margin:0 auto}
  </style>


## 정리 노트

<h3>협약에 의한 설계를 따를 경우에 포함되어야할 조건<caption1> 📘 1과목_C1 소프트웨어의 분류와 특성</caption1></h3>


<br>
&nbsp;&nbsp; <daon> " 선행, 결과, 불변 " </daon>
<br>

<br>
<h3>화이트박스<caption1> 📘 2과목_C4 애플리케이션 테스트 </caption1></h3>
<br>
&nbsp;&nbsp; <daon> " 모든 소스 코드의 논리적인 경로를 테스트 케이스로 설계하는 방법 " </daon>
<br>

* 테스트 과정 초기에 실행
* 소스 코드 모든 문장 한 번 이상 수행
* 제어 구조 검사
  + 조건 검사
    - 소스 코드의 논리적 조건을 테스트
  + 루프 검사
    - 소스 코드의 반복 구조를 중심적으로 테스트
  + 데이터 흐름 검사
    - 소스 코드의 변수 정의, 사용을 중심적으로 테스트

<h3>블랙박스<caption1> 📘 2과목_C4 애플리케이션 테스트 </caption1></h3>
<br> 
&nbsp;&nbsp; <daon> " 요구사항 명세서를 기반으로 구현된 기능을 테스트 케이스로 설계하는 방법 " </daon>
<br>

* 인터페이스에서 테스트
* 기능 및 인터페이스 ,데이터 접근, 성능 등의 오류를 발견하기 위해

+ 동치 분할 검사
  - 입력 조건에 유효한 값과 무효한 값을 균등하게 하여 테스트
+ 경계값 분석
  - 입력 조건의 경계에서 오류가 발생할 확률이 높다는 점을 이용하여 그 값 대입
+ 원인-효과 그래프 검사
  - 입력 데이터 간의 관계와 출력에 미치는 영향을 분석하여 효용성이 높은 테스트 케이스 설계
+ 오류 예측 검사
  - 과거의 경험이나 확인자의 감각에 의존하여 테스트 케이스 설계
+ 비교 검사
  - 여러 버전의 프로그램에 동일한 테스트 자료를 제공하여 테스트

<br>
<h3>테스트 오라클<caption1> 📘 2과목_C4 결함 관리</caption1></h3>
<br>
&nbsp;&nbsp; <daon> " 테스트 결과가 올바른지 판단하기 위해 사전에 정의된 참 값을 대입하여 비교 " </daon>
<br>

* 결과를 판단하기 위해 테스트 케이스에 대한 예상 결과를 계산하거나 확인

* 🔥 테스트 시나리오는 여러 개의 테스트 케이스들을 순서대로 진행할 수 있도록 묶은 집합

<br>
<h3>정적 분석 도구<caption1> 📘 2과목_C4 성능 분석 및 품질 평가</caption1></h3>
<br>
&nbsp;&nbsp; <daon> " 프로그램을 실행하지 않고 코드 구조를 분석하는 도구 " </daon>
<br>

* pmd
* cppcheck
* SonarQube
* checkstyle

<br>
<h3>연계 응용 프로그램 구현<caption1> 📘 2과목_C2 인터페이스 구현</caption1></h3>

* 운영 데이터베이스에서 데이터 추출 및 테이블 생성
* 자신의 코드를 목적 시스템의 코드로 변환
* 연계 테입즐의 데이터 유효성 처리

<br>
<h3>소프트웨어 버전 관리 도구 유형<caption1> 📘 2과목_C3 제품 소프트웨어 버전관리</caption1></h3>

+ 공유 폴더 방식
  - 완료된 파일을 정해진 위치로 복사
  - 담당자는 공유 파일이 자신의 컴퓨터에서 정상적으로 실행되는지 확인
  - RCS
+ 클라이언트/서버 방식
  - 버전 관리 도구가 중앙 시스템에서 항상 작동중
  - 서로 다른 개발자가 같은 파일을 작업하면 경고
  - 시점별 작업 내용 저장이 용이하여 GUI 툴을 이용하여 모니터링 가능
+ 분산 저장소 방식
  - 로컬 저장소와 원격 저장소를 함께 활용
  - 개발이 완료된 소스 코드를 로컬 저장소에 반영한 뒤 원격 저장소에 복사
  - Git, BitKeeper, ClearCase

<br>
<h3>살충제 패러독스<caption1> 📘 2과목_C4 애플리케이션 테스트</caption1></h3>
<br>
&nbsp;&nbsp; <daon> " 동일한 테스트 케이스를 반복 실행하면 더 이상 새로운 결함을 발견할 수 없으므로<br> 주기적으로 테스트 케이스를 개선하여 테스트 진행 " </daon>
<br>

<br>
<h3>결함 집중<caption1> 📘 2과목_C4 애플리케이션 테스트</caption1></h3>
<br>
&nbsp;&nbsp; <daon> " 결함의 대부분은 소수의 특정 모듈에서 발생 " </daon>
<br>

+ 낚시의 법칙
  - 낚시 포인트처럼 특정 위치에 많은 결함
+ 파레토의 법칙
  - 소프트웨어 결함의 80%는 20%에서 발생

<br>
<h3>정렬의 종류와 시간복잡도<caption1> 📘 2과목_C1 정렬</caption1></h3>

|정렬|평균|최악|
|:-----:|:-----:|:-----:|
|**삽입 정렬**|O(n^2)|O(n^2)|
|**버블 정렬**|O(n^2)|O(n^2)|
|**선택 정렬**|O(n^2)|O(n^2)|
|**쉘 정렬**|O(n^1.5)|O(n^1.5)|
|**힙 정렬**|O(nlogn)|O(nlogn)|
|**이진 병합 정렬**|O(nlogn)|O(nlogn)|
|**퀵 정렬**|O(nlogn)|O(n^2)|
|**버킷 정렬**|O(dn)|O(dn)|

<br>
<h3>인터페이스 설계서<caption1> 📘 2과목_C2 인터페이스 구현</caption1></h3>

* 인터페이스 현황을 쉽게 확인하기 위해 한 시스템이 갖는 인터페이스 목록
* 인터페이스의 상세 데이터 명세와 각 기능의 세부 인터페이스 정보를 정의
* 각 시스템의 교환 데이터, 업무, 송수신 주체 등이 정의되어 있음

* 🔥 인터페이스 번호, 인터페이스되는 시스템의 정보, 관련 요구사항 ID를 목록화 한 것은 <span id="mus">인터페이스 명세서</span>

<br>
<h3>V 모델<caption1> 📘 2과목_C2 인터페이스 구현</caption1></h3>

* 애플리케이션 테스트와 소프트웨어 개발 단계를 연결하여 표현
* 소프트웨어 개발 단계에 따라 단위 테스트, 통합 테스트, 시스템 테스트, 인수 테스트 순으로 진행
* 각각의 개발 단계에 대한 완성도를 개발자 관점에서 검증하고, 각각의 개발 결과를 사용자 관점에서 확인
* <u>폭포수 모델</u >에서 확장된 형태를 보이며 어느 단계에서 발생한 오류인지 추적 가능

<br>
<h3>E-R 다이어그램 작성 시 고려사항<caption1> 📘 3과목_C1 E-R 다이어그램</caption1></h3>

* 개체들은 정렬하여 중심부에 배열하고 관계있는 게체는 서로 가까이 둠
* 업무 흐름과 관련된 개체는 진행 순서에 따라 왼쪽 위에서 오른쪽 아래로 배열
* 사선이 아닌 수직, 수평선을 이용하여 관계를 표시함
* 교차선이나 관계선이 너무 길지 않게끔 배열
* 관계있는 개체끼리 묶어줌

* 💡 관계는 마름모로 표현

<br>
<h3>뷰(View)<caption1> 📘 3과목_C1 인덱스와 뷰</caption1></h3>
<br>
&nbsp;&nbsp; <daon> " 다른 테이블로부터 유도된 하나의 테이블을 가르키며,<br> 이를 유도하는 데 사용된 테이블을 정의 테이블이라고 함 " </daon>
<br>

* 자주 참조되는 테이블에 대해서 생성되고 편리하며 임의 보안 절차에 사용
* 뷰를 생성할 때는 CREATE 문 사용

* 🔥 삽입, 삭제에 많은 제한이 있음 

<br>
<h3>클러스터(Cluster)와 파티션(Partition)<caption1> 📘 3과목_C4 물리 데이터 모델 설계</caption1></h3>
<br>
&nbsp;&nbsp; <daon> " 데이터 저장 시 데이터 엑세스 효율을 향상시키기 위해 동일한 성격의 데이터를<br> 동일한 데이터 블록에 저장하는 물리적 저장 방법 " </daon>
<br>

+ 클러스터의 고려사항
  - 조회는 빨라지지만, 입력, 수정 삭제에 대한 성능은 저하
  - 전체 테이블을 스캔하는 일이 자주 발생할때는 클러스터링을 하지 않는 것이 좋음
  - 처리 범위가 넓은 경우에는 단일 테이블 클러스터링을, 조인이 많이 발생하는 경우는 다중 테이블 클러스터링을 사용 
  - 데이터 분포도가 넓은 테이블을 클러스터링하면 저장 공간 절약 (특정 필드값을 기준으로 정렬하고 분리하기 때문에)


+ 파티션의 고려사항
  - 대용량의 테이블을 논리적인 단위의 작은 테이블로 나누어 성능 저하 방지 및 관리를 용이하게 하는 것
  - 데이터 접근 시 액세서 범위를 줄여 쿼리 성능 향상
  - 파티션 별로 백업 및 복구를 수행하므로 속도가 빠름
  - 조인에 대한 비용 증가
  - 전체 데이터의 훼손 가능성이 감소되고 데이터의 가용성이 증가

+ 파티션의 유형
  - 범위(Range) 분할
  - 해시(Hash) 분할
  - 조합(Composite) 분할
  - 목록(List) 분할

<br>
<h3>관계 대수의 개념<caption1> 📘 3과목_C1 정규화 </caption1></h3>

* 연산자 또는 연산 규칙을 사용하여 기술하는 절차식 언어
* 주어진 관계로부터 원하는 데이터와 그 데이터를 유도하는 연산자
* 릴레이션을 조작하여 특정 릴레이션을 만들어냄
* 일반 집합 연산과 순수 관계 연산자로 구분

<br>
<h3>곱집합(Cartensian Product)<caption1> 📘 3과목_C1 정규화</caption1></h3>
<br>
&nbsp;&nbsp; <daon> " 기수는 튜플의 개수, 차수는 속성의 개수 " </daon>
<br>

* 차수는 속성의 합
* 기수는 튜플의 곱

<br>
<h3>데이터 모델링의 구성 요소<caption1> 📘 3과목_C1 논리 데이터 모델링</caption1></h3>
<br>
&nbsp;&nbsp; <daon> " 논리적 구조, 연산, 제약조건 " </daon>

<br>
<h3>논리적 설계의 3단계<caption1> 📘 3과목_C1 논리 데이터 모델링</caption1></h3>
<br>
&nbsp;&nbsp; <daon> " 논리적 설계란 개념 데이터 모델을 상세화하여<br> 논리적인 데이터 집합, 관리 항목, 관계 등을 정의 " </daon>

* 논리적 데이터베이스 구조로 매핑
* 트랜잭션 인터페이스를 설계
* 스키마의 평가 및 최적화

<br>
<h3>정규형<caption1> 📘 3과목_C1 정규화</caption1></h3>

* 비정규형
<br>

|직원코드|직원명|담당|
|:-----:|:-----:|:-----:|
|C01|오영희|루팡, 탕비실 훔치기|
|C02|김철수|화장 고치기, 담배피기|

+ 1NF
  - 릴레이션의 모든 속성 및 도메인이 원자성을 가짐


|직원코드|직원명|담당|
|:-----:|:-----:|:-----:|
|C01|오영희|루팡|
|C01|오영희|탕비실 훔치기|
|C02|김철수|화장 고치기|
|C02|김철수|담배피기|

+ 2NF
  - 기본키가 아닌 모든 속성들이 기본키에 완전 함수 종속
  - 아래의 직원 코드만으로 직원명 구분 가능하니 분할

|직원코드|직원명|
|:-----:|:-----:|
|C01|오영희|
|C02|김철수|

|직원코드|담당|
|:-----:|:-----:|
|C01|루팡|
|C01|탕비실 훔치기|
|C02|화장 고치기|
|C02|담배피기|

<br>

+ 3NF
  - 이행적 함수 종속을 제거한 릴레이션 스키마
  - 기본키 이외에 다른 컬럼이 그외 다른 컬럼을 결정하지 못함
  - 분리하여 다른 테이블의 기본키로 만들면 됨

+ 나누기 전

|<u>직원코드</u>|직원명|<u>담당</u>|주소|주소상세|우편번호|
|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|
|001|김개똥|화장실가기|서울시|금천동|1234|
|001|김개똥|산책하기|서울시|금천동|1234|
|002|김태희|캐리하기|서울시|신당동|4321|
|003|강동원|쇼핑하기|서울시|옥천동|1212|
|003|강동원|웃기|서울시|옥천동|1212|

+ 나눈 후

|<u>직원코드</u>|직원명|주소|주소상세|우편번호|
|:-----:|:-----:|:-----:|:-----:|:-----:|
|001|김개똥|서울시|금천동|1234|
|001|김개똥|서울시|금천동|1234|
|002|김태희|서울시|신당동|4321|
|003|강동원|서울시|옥천동|1212|
|003|강동원|서울시|옥천동|1212|


|<u>직원코드</u>|<u>담당</u>|
|:-----:|:-----:|
|001|화장실가기|
|001|산책하기|
|002|캐리하기|
|003|쇼핑하기|
|003|웃기|

<br>

+ BCNF
  - 결정자이면서 후보키가 아닌 함수 종속을 제거한 릴레이션 스키마
  - 모든 결정자가 후보키이면 BCNF
  - 아래와 같이 후보키가 여러 개면 분리(송장 번호가 배송지를 결정)

+ 나누기 전

|<u>거래 ID</u>|<u>제품 코드</u>|송장 번호|배송지|
|:-----:|:-----:|:-----:|:-----:|
|1|1234|0001|Delta|
|1|1235|0001|Delta|
|2|1235|0002|Ohio|

+ 나눈 후

|<u>거래 ID</u>|<u>제품 코드</u>|송장 번호|
|:-----:|:-----:|:-----:|
|1|1234|0001|
|1|1235|0001|
|2|1235|0002|

|<u>송장 번호</u>|배송지|
|:-----:|:-----:|
|0001|Delta|
|0002|Ohio|


* 🔥 후보키를 통하지 않은 조인 종속을 제거한 릴레이션 스키마는 <span id="mus">5NF</span>


<br>
<h3>데이터 모델링의 구성 요소<caption1> 📘 4과목_C3 객체지향 기술</caption1></h3>
<br>
&nbsp;&nbsp; <daon> " 매개변수로 전달되는 인수의 타입과 개수를 식별하여<br> 적절한 메소드를 호출해 주는 기능 " </daon>


<br>
<h3>객체지향 분석 절차<caption1> 📘 4과목_C3 객체지향 개발 절차</caption1></h3>
<br>
&nbsp;&nbsp; <daon> " 객체 모델링 -> 동적 모델링 -> 기능 모델링 " </daon>


<br>
<h3>전용 회선<caption1> 📘 5과목_C3 통신망 기술</caption1></h3>
<br>
&nbsp;&nbsp; <daon> " 컴퓨터 주소, 경로 선택이 필요 없으며 보안이 좋고, 사용 비용 비쌈 " </daon>

* 🔥 컴퓨터 사이에 교환기가 존재하는 것은 <span id="mus">교환 회선</span>

<br>
<h3>Smurf Attack(Smurfing)<caption1> 📘 5과목_C5 악성 프로그램</caption1></h3>
<br>
&nbsp;&nbsp; <daon> " 고성능 컴퓨터를 이용해 초당 엄청난 양의 접속 신호를 한 사이트에 집중적으로 보냄으로써...  " </daon>

<br>
<h3>대치 암호의 종류<caption1> 📘 5과목_C6 암호 기술</caption1></h3>
<br>
&nbsp;&nbsp; <daon> " 아핀, 카이저, 선형  " </daon>

<br>
<h3>해시 함수를 이용한 암호화 알고리즘<caption1> 📘 5과목_C6 암호 기술</caption1></h3>
<br>

&nbsp;&nbsp; <daon> " SNEFRU, MD4, MD5, N-NASH, SHA  " </daon>

<br>
<h3>대치 암호의 종류<caption1> 📘 5과목_C6 암호 기술</caption1></h3>

* 암호화 키와 복호화 키가 다름
* 암호화 키는 공개하고, 복호화 키는 비밀리에 보관
* 비대칭키, 공영키 방식으로 전자서명에 적합
* RSA는 소인수 분해가 어렵다는 점을 이용한 공개키 암호화 기법

<br>
<h3>신기술 동향<caption1> 📘 5과목_C5 신기술 동향</caption1></h3>

+ Digital Twin
  - 물리적인 자산을 컴퓨터에 동일하게 표현
  - 실제 자산의 특성에 대한 정확한 정보를 얻을 수 있음

+ 분산 원장 기술(DLT: Distributed Ledger Technology)
  - 중앙 관리자나 중앙 데이터 저장소가 존재하지 않고 P2P망 내의 참여자들에게 모든 거래 목록이 분산 저장
  - 블록체인의 기술

+ 디지털 저작권 관리(DRM: Digital Rights Management)
  - 유통되는 데이터의 저작권 보호를 위해 만든 시스템

+ 공통 평가 기준
  - ISO 15408 표준으로 채택된 정보 보호 제품 평가 기준

+ 그레이웨어(Grayware)
  - 소프트웨어를 제공하는 입장에서는 악의성이 없더라도 사용자 입장에서 악의적이라고 판단될 수 있는 애드웨어 등

+ 시맨틱 웹(Sementic Web)
  - 사람을 대신해서 컴퓨터가 정보를 읽고 이해하고 가공

+ 증발품(Vaporware)
  - 판매 또는 배포 계획이 있었으나 실제로 고객에게 판매되거나 배포되지 않은 소프트웨어

+ 오픈 그리드 서비스 아키텍처(OGSA: Open Grid Service Architcture)
  - 애플리케이션 공유를 위한 앱 서비스를 그리드상에서 제공하기 위해 만든 개방형 표준

+ 서비스 지향 아키텍처(SOA: Service Oriented Architecture)
  - 기업의 소프트웨어 인프라인 정보시스템을 공유와 재사용이 가능한 서비스 단위나 컴포넌트 중심으로 구축하는 정보 기술 아키텍처

+ 소프트웨어 에스크로(Software Escrow)
  - 소프트웨어 개발자의 지식재산권을 보호하고 사용자는 저렴한 비용으로 소프트웨어를 안정적으로 사용 및 유지보수 받을 수 있도록 소스 프로그램과 기술정보 등을 제3기관에 보관하는 것


<br>
<h3>데이터 신기술 동향<caption1> 📘 5과목_C5 신기술 동향</caption1></h3>

+ Hadoop
  - 오픈 소스를 기반으로 한 분산 컴퓨팅 플랫폼
  - 가상화된 대형 스토리지를 형성하고 그 안에 보관된 거대한 데이터 세트를 병렬로 처리할 수 있도록 개발된 자바 소프트웨어 프레임워크
    * 맵리듀스(MapReduce): 흩어져 있는 데이터를 연관성있는 것들끼리 묶는 작업을 수한한 뒤, 중복 데이터 제거하고 원하는 데이터 추출
    * 스쿱: 하둡과 관계형 데이터베이스 간에 데이터를 전송할 수 있도록 설계된 도구 